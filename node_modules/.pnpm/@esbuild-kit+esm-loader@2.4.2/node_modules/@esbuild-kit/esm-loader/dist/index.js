import l from"path";import{fileURLToPath as W,pathToFileURL as v}from"url";import{installSourceMapSupport as D,compareNodeVersion as w,resolveTsPath as F,transform as P,applySourceMap as f,transformDynamicImport as k}from"@esbuild-kit/core-utils";import{parseTsconfig as A,getTsconfig as I,createPathsMatcher as L}from"get-tsconfig";import T from"fs";const u=D(),d=process.env.ESBK_TSCONFIG_PATH?{path:process.env.ESBK_TSCONFIG_PATH,config:A(process.env.ESBK_TSCONFIG_PATH)}:I(),E=d==null?void 0:d.config,S=d&&L(d),y=/\.([cm]?ts|[tj]sx)$/,j=t=>{const s=l.extname(t);if(s===".mjs"||s===".mts")return"module";if(s===".cjs"||s===".cts")return"commonjs"},g=new Map;async function M(t){if(g.has(t))return g.get(t);if(!await T.promises.access(t).then(()=>!0,()=>!1)){g.set(t,void 0);return}const o=await T.promises.readFile(t,"utf8");try{const n=JSON.parse(o);return g.set(t,n),n}catch{throw new Error(`Error parsing: ${t}`)}}async function x(t){let s=new URL("package.json",t);for(;!s.pathname.endsWith("/node_modules/package.json");){const o=W(s),n=await M(o);if(n)return n;const r=s;if(s=new URL("../package.json",s),s.pathname===r.pathname)break}}async function O(t){var s;const o=await x(t);return(s=o==null?void 0:o.type)!=null?s:"commonjs"}const b=[".js",".json",".ts",".tsx",".jsx"];async function U(t,s,o){let n;for(const r of b)try{return await h(t+r,s,o,!0)}catch(a){if(n===void 0){const{message:i}=a;a.message=a.message.replace(`${r}'`,"'"),a.stack=a.stack.replace(i,a.message),n=a}}throw n}async function N(t,s,o){const n=t.endsWith("/")?"index":"/index";try{return await U(t+n,s,o)}catch(r){const{message:a}=r;throw r.message=r.message.replace(`${n.replace("/",l.sep)}'`,"'"),r.stack=r.stack.replace(a,r.message),r}}const R="file://",C=/^\.{0,2}\//,H=w([14,13,1])>=0||w([12,20,0])>=0,h=async function(t,s,o,n){var r,a;if(!H&&t.startsWith("node:")&&(t=t.slice(5)),t.endsWith("/"))return await N(t,s,o);const i=t.startsWith(R)||C.test(t);if(S&&!i&&!((r=s.parentURL)!=null&&r.includes("/node_modules/"))){const e=S(t);for(const p of e)try{return await h(v(p).toString(),s,o)}catch{}}if(y.test(s.parentURL)){const e=F(t);if(e)try{return await h(e,s,o,!0)}catch(p){const{code:_}=p;if(_!=="ERR_MODULE_NOT_FOUND"&&_!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw p}}let c;try{c=await o(t,s,o)}catch(e){if(e instanceof Error&&!n){if(e.code==="ERR_UNSUPPORTED_DIR_IMPORT")return await N(t,s,o);if(e.code==="ERR_MODULE_NOT_FOUND")return await U(t,s,o)}throw e}if(c.url.endsWith(".json"))return{...c,format:"json"};let{format:m}=c;return c.url.startsWith(R)&&(m=(a=j(c.url))!=null?a:m,m||(m=await O(c.url))),{...c,format:m}},K=async function(t,s,o){process.send&&process.send({type:"dependency",path:t}),t.endsWith(".json")&&(s.importAssertions||(s.importAssertions={}),s.importAssertions.type="json");const n=await o(t,s,o);if(!n.source)return n;const r=n.source.toString();if(n.format==="json"||y.test(t)){const i=await P(r,t,{tsconfigRaw:E});return{format:"module",source:f(i,t,u)}}const a=k(r);return a&&(n.source=f(a,t,u)),n},$=async function(t,s,o){var n;return t.endsWith(".json")?{format:"module"}:t.startsWith("file:")?{format:(n=j(t))!=null?n:await O(t)}:await o(t,s,o)},B=async function(t,s,o){const{url:n}=s;if(process.send&&process.send({type:"dependency",path:n}),n.endsWith(".json")||y.test(n)){const i=await P(t.toString(),n,{tsconfigRaw:E});return{source:f(i,n,u)}}const r=await o(t,s,o),a=k(r.source.toString());return a&&(r.source=f(a,n,u)),r},J=w([16,12,0])<0,G=J?$:void 0,V=J?B:void 0;export{G as getFormat,K as load,h as resolve,V as transformSource};
